libs:
  - d3
  - domtree

---

## Навигация по DOM-элементам

Для того, чтобы производить операции над элементами DOM нужно получить (найти) соответствующий DOM-объект.
Все операции с DOM начинаются с объекта document. Это главная "точка входа" в DOM. Из него мы можем получить доступ к любому узлу.

Самые верхние элементы DOM-дерева доступны как свойства элемента document:

Самый верхний узел документа: document.documentElement соответствует тегу `<HTML>`.
Еще пример: document.body соответствует тегу `<body>`, document.head - тегу `<head>`.

--document.body может быть равен null. Такое может произойти, если мы обращаемся к ещё не существующему элементу, например, если скрипт находится в head.--

В DOM значение null означает "не существует" или "нет такого узла"

## Дети: childNodes, firstChild, lastChild.

Существует 2 принципиально разных термина: 
1) "Дочерние узлы" - элементы, которые являются непосредственно детьми узла. Например `<head>` и `<body>` являются детьми `<html>`.
2) "Потомки" - все элементы, которые лежат внутри данного, включая детей и их детей и т.д.

Пример:
Последовательно выведем детей document.body:
```html run
<html>
<body>
  <div>Начало</div>

  <ul>
    <li>Информация</li>
  </ul>

  <div>Конец</div>

  <script>
*!*
    for (let i = 0; i < document.body.childNodes.length; i++) {
      alert( document.body.childNodes[i] ); // Text, DIV, Text, UL, ..., SCRIPT
    }
*/!*
  </script>
  ...какой-то HTML-код...
</body>
</html>
```
В примере выше "...какой-то HTML-код..." не будет выведен, т.к. script находится выше и на момент выполнения скрипта браузер ещё не дошел до этого узла.

**Свойства 'firstChild' и 'lastChild' обеспечивают быстрый доступ к первому и последнему дочернему элементу.**

Условие ниже всегда верно:
```js
elem.childNodes[0] === elem.firstChild
elem.childNodes[elem.childNodes.length - 1] === elem.lastChild
```

Для проверки наличия дочерних узлов существует также специальная функция 'elem.hasChildNodes()'.

### DOM-коллекции

'childNodes' похож на массив. На самом деле это *коллекция* - особый перебираемый объект-псевдомассив.

Из этого следует:
1) Для перебора *коллекции* мы можем использовать 'for...of':
'''js run
for (let node of document.body.childNodes)
{
    alert(node);
    // покажет все узлы `<body>`
}
'''

Это работает, потому что колекция является перебираемым объектом (есть метод 'Symbol.iterator').

2) Метод массивов не будут работать, т.к. коллекция - это не массив:
'''js run
alert(document.body.childNodes.filter);
// undefind т.к. у коллекции нет метода filter
'''

Если нам нужен массив, то мы можем его создать из коллекции используя 'Array.from':
'''js run
alert(Array.from(document.body.childNodes).filter);
'''

### DOM-коллекции - только для чтения!

Также как и все навигационные свойства.
Мы не можем заменить один дочерний узел на другой написав 'childNodes[i] = ...'.

Для изменения применяются другие методы.

### DOM-коллекции - "живые".
Они отражают текущее состояние DOM.

Если мы сохраним ссылку на 'elem.childNodes' и добавим/удалим узлы в DOM, то изменения появятся в сохраненной коллекции автоматически.

Не корректно использовать цикл 'for...in' для перебора коллекции, т.к. он перебирает все перечисляемые свойства, а у коллекций есть некоторые "лишние", редко используемые свойства.

## Соседи и родитель

*Соседи* - это узлы, у которых один и тот же родитель.
Например `<head>` и `<body>`.

-`<body>` - следующий или правый сосед, в свойстве - 'nextSibling'.
-`<head>` - предедущий или левый сосед, в свойстве - 'previousSibling'.

Родитель доступен через 'parentNode'.

## Навигация только по элементам

Навигац свойства, описанные выше, относятся ко всем узлам в документа. В частности, в 'childNodes' могут находится текстовые узлы, узлы-комментарии и т.д.

Для манипуляции только узлами-элементами применяются свойства:
-'children';
-'firstElementChild', 'lastElementChild';
-'previousElementSibling', 'nextElementSibling';
-'parentElement' - обычно одинаковы с 'parentNode', исключение 'document.documentElement':
```js run
// выведет document
alert(document.documentElement.parentNode);
// выведет null
alert(document.documentElement.parentElement);
```

Причина в том, что родителем корневого узла 'document.documentElement' (`<html>`) является 'document', но он не является узлом-элементом.

Некоторые типы DOM-элементов используют другие свойства.

Например таблицы:

Элемент `<table>` дополнительно использует свойства:

-'table.rows' - коллекция строк `<tr>` таблицы;

-'table.caption/tHead/tFoot' - ссылки на элемент таблицы `<caption>`, `<thead>`, `<tfoot>` соответственно;

-'table.tBodies' - коллекция элементов таблицы `<tbody>` (может быть больше одного).

У **`<thead>`, `<tfoot>`, `<tbody>`** есть свойство 'rows':
-'tbody.rows' - коллекция строк `<tr>` секции.

**`<tr>`:**

-'tr.cells' - коллекция `<td>` и `<th>` ячеек, находящихся внутри строки `<tr>`;

-'tr.sectionRowIndex' - номер строки '\<tr>' в текущей секции `<thead>`/`<tfoot>`/`<tbody>`;

-'tr.rowIndex' - номер строки `<tr>` в таблице (включаяя все строки таблицы).

**`<td>` и `<th>`:**
-'td.cellIndex' - номер ячеек в строке `<tr>`.

Пример:
```html run height=100
<table id = "table">
    <tr>
        <td>один</td>
        <td>два</td>
    </tr>
    <tr>
        <td>три</td>
        <td>четыре</td>
    </tr>
</table>
<script>
    // выводит содержимое первой строки, второй ячейки
    alert(table.row[0].cells[1].innerHTML) //два
</script>
```

Также существуют дополнительные навигационные ссылки для HTML-форм.
