# Класс: базовый синтаксис

```quote author="Википедия"
В объектно-ориентированном программировании *класс* - это расширяемый шаблон кода для создания объектов, который устанавливает в них начальные значения (свойства) и реализацию поведения (методы).
```

На практике нам часто надо создавать много объектов одного вида, например пользователей, товары или что-то ещё.

Как мы уже знаем из главы <info:constructor-new>, с этим может помочь `new function`.

Но в современном JavaScript есть и более продвинутая конструкция "class", которая предоставляет новые возможности, полезные для объектно-ориентированного программирования.

## Синтаксис "class"

Базовый синтаксис выглядит так:
```js
class MyClass {
  // методы класса
  constructor() { ... }
  method1() { ... }
  method2() { ... }
  method3() { ... }
  ...
}
```

Затем используйте вызов `new MyClass()` для создания нового объекта со всеми перечисленными методами.

При этом автоматически вызывается метод `constructor()`, в нём мы можем инициализировать объект.   

Например:

```js run
class User {

    constructor(name){
        this.name = name;
    }

    sayHi() {
        alert(this.name);
    }
}

let user = new User('John');
user.sayHi();
```

Когда вызывается `new User("Иван")`:
1. Создается новый объект. 
2. `constructor` запускается с заданным аргументом и сохраняет его в `this.name`.

Затем можно вызвать на объекте методы, такие как `user.sayHi()`.

"Методы класса не разделяются запятой"
Частая ошибка начинающих разработчиков - ставить запятую между методами класса, что приводит к синтаксической ошибке. 

Синтаксис классов отличется от литералов объектов, не путайте их. Внутри классов запятые не требуются. 

## Что такое класс?

Класс - это не полность языковая сущьность как может показаться на первый взгляд. 

В JavaScript класс - это раазновидность функции:

```js run
class User {
    constructor(name) {this.name = name};
    sayHi() {alert(this.name)};
}

// доказательство: User - это функция
alert(typeof User); // function
```

Вот что на самом деле делает конструкция `class User {...}`:

1. Создает функцию с именем `User`, которая становится результатом объявления класса. Кода функции берется из метода `constructor` (она будет пусто, если такого метода нет). 
2. Сохраняются все методы, такие как `sayHi`, в `User.prototype`.

При вызове метода объекта `new User` он будет взять из прототипа, как описано в главе <info:function-prototype>. Таким образом, объекты `new User` имеют доступ к методам класса.

Это можно проверить:

```js run
class User {
    constructor(name) {this.name = name};
    sayHi() {alert(this.name)};
}

// класс - это функция
alert(typeof User) // function

// ...или, если точнее, это метод constructor
alert(User === User.prototype.constructor); // true

// Методы находятся в User.prototype, например:
alert(User.prototype.sayHi); // alert(this.name);

// в прототипе ровно 2 метода
alert(Object.getOwnPropertyNames(User.prototype)); // constructor, sayHi
```

## Не просто синтаксический сахар

Говорят, что `class` - это просто "синтаксический сахар" в JavaScript (синтаксис для улучшения читаемости кода, но не делающий ничего принципиально нового), потому как мы можем сделать все то же самое и без конструкции `class`:

```js run
// перепишем класс User на чистых функциях

// 1. Создаём функцию constructor
function User(name) {
    this.name = name;
}

// каждый прототип функции имеет свойство constructor по умолчанию,
// поэтому нам нет необходимости его создавать

// 2. Добавляем метод в прототип
User.prototype.sayHi = function() {
    alert(this.name);
};

// Использование:
let User = new User('John');
user.sayHi();
```

Результат этого кода очень похож.
Однако есть важные отличия:

1. Функция, созданная с помощью `class`, помечена специальным внутренним свойством `[[FunctionKind]]:"classConstructor"`. Поэтому это не совсем то же самое, что создаавать ее вручную. 
    В отлие от обычных функций, конструктор не может быть вызван без `new`:
    
    ```js run
    class User {
        constructor() {}
    }
    alert (typeof User); // function

    User(); //Error: Class constructor User cannot be invoked without 'new'
    ```

    Кроме того, строковое предоставление конструктора класса в большенстве движков JavaScript начинается с "class ..."

    ```js run
    class User {
        constructor() {}
    }

    alert(User); // class User {...}
    ```

2. Методы класса являются не перечислимыми. Определение класса устанавливает флаг `enumerable` в` false` для всех методов в `"prototype"`.

    И это хорошо, т.к., если мы проходимся целиком `for..in` по объекту, то обычно мы не хотим при этом получать методы класса. 

3. Классы всегда используют `use strict`. Весь кода внутри класса автоматически находится в строгом режиме. 

Также в дополнение к основному, описанному выше, функционалу, синтаксис `class` дает ряд других интересных возможностей. 

## Class Expression

Как и функции, классы можно определять внутри другого выражения, передавать, возвращать, присваивать и т.д.

Пример Class Expression (по аналогии с Function Expression):

```js
let User = class {
    sayHi(){
        alert('Hello');
    }
};
```

Аналогично Named Function Expression, Class Expression может иметь имя.

Если у Class Expression есть имя, то оно видно только внутри класса:

```js run
// "Named Class Expression"
// (в спецификации нет такого термина, но происходящее похоже на Named Function Expression)
let User = calss MyClass {
    sayHi() {
        alert(MyClass); //  имя MyClass видно только внутри класса
    }
};

new User().sayHi(); // работает, выводит определение MyClass

alert(MyClass); // ошибка, имя MyClass не видно за пределами класса
```

Мы даже можем динамически создаавать классы "по запросу":

```js run
function makeClass(phrase) {
    // объявляем класс и возвращаем его
    return class {
        sayHi() {
            alert(phrase);
        }
    };
}

// Создаём новый класс
let User = makeClass('Hello');

new User().sayHi(); // Hello
```

## Геттеры/сеттеры, другие сокращения

Как и в литеральных объектах, в классах можно объялять генераторы, вычисляемые свойства, геттеры/сеттеры и т.д.

Вот пример `user.name`, реализованного с использованием `get/set`:

```js run
class User {
    constructor(name){ 
        // вызывает сеттер
        this.name = name;
    }

    get name() {
        return this._name;
    }

    set name(value) {
        if (value.length < 4) {
            alert('Too short name');
            return;
        }
        this._name = value;
    }   
}

let user = new User('John');
alert(user.name); // John

user = new User('') // Too short name
```

При объявлении класса геттеры/сеттеры создаются на `User.prototype`, вот так:

```js
Object.defineProperties(User.prototype, {
    name: {
        get() {
            return this._name;
        },
        set(name) {
            if (name.length < 4) {
            alert('Too short name');
            return;
        }
        this._name = name;
        }
    }
});
```

Пример с вычисляемым свойством в скобках `[...]`:

```js run
class User {
    ['say' + 'Hi']() {
        alert('Hello')
    }
}

new User().sayHi();
```

Для методов-генераторов добавьте перед именем `*`.

## Свойства классов

"Старым браузерам может понадобится полифил"
Свойства классов добавлены в язык недавно. 

В приведенном выше примере у класса  `User` были только методы. Можно также добавлять и свойства:

```js run
function User {
    name = 'Anonim';

    sayHi() {
        alert(this.name)
    }
}

new User().sayHi();
```

Свойство `name` не устанавливается в `User.prototype`. Вместо этого оно создаётся оператором `new` перед запуском конструктора, это именно свойство объекта.

## Итого

Базовый синтаксис для классов выглядит так:

```js
class MyClass {
    prop = value // свойство
    constructor(...) { // конструктор
        // ...
    }
    method(...) {} // метод
    get something() {} // геттер
    set something(...) {} // сеттер
    [Symbol.iterator]() {} // метод с вычисляемым именем (здесь - символом)
    // ...
}
```

`MyClass` технически является функцией (той, которую мы определяем как `constructor`), в то вркмя как методы, геттеры и сеттеры записываются в  `MyClass.prototype`.

