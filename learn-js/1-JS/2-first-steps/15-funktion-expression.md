# Function Expression и функции-стрелки

Функции в JS - это особого типа значения.
Существует 2 вида синтаксиса:
1) *Function Declaration* (Объявление функции):
```js
function sayHi() {
  alert( "Привет" );
}
```
2) *Function Expression* (Функциональное выражение):
```js
let sayHi = function() {
  alert( "Привет" );
};
```

Последняя функция создается и присваивается переменной.

Смысл обоих примеров одинаков - сщздать функцию и поместить ее значение в переменную `sayHi`.

Мы можем вывести это значение с помощью `alert`:

```js run
function sayHi() {
  alert( "Привет" );
}

alert( sayHi ); // выведет код функции
```

Последняя строка не вызывает функцию `sayHi` (после ее имени нет круглых скобок).

Мы можем скопировать функции в другую переменную:
```js run no-beautify
function sayHi() {   // (1) создаём
  alert( "Привет" );
}

let func = sayHi;    // (2) копируем

func(); // Привет    // (3) вызываем копию (работает)!
sayHi(); // Привет   //     прежняя тоже работает (почему бы нет)
```
Заметим, что мы могли бы использовать и Function Expression для того, чтобы создать `sayHi` в первой строке:

```js
let sayHi = function() {
  alert( "Привет" );
};

let func = sayHi;
// ...
```

Результат был бы таким же.

## Функции-"колбэки"

Напишем функцию `ask(question, yes, no)` с тремя параметрами:

`question`
: Текст вопроса

`yes`
: Функция, которая будет вызваться, если ответ будет "Yes"

`no`
: Функция, которая будет вызываться, если ответ будет "No"

Наша функция должна задать вопрос `question` и, в зависимости от того, как ответит пользователь, вызвать `yes()` или `no()`:

```js run
*!*
function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}
*/!*

function showOk() {
  alert( "Вы согласны." );
}

function showCancel() {
  alert( "Вы отменили выполнение." );
}

// использование: функции showOk, showCancel передаются в качестве аргументов ask
ask("Вы согласны?", showOk, showCancel);
```

На практике подобные функции очень полезны. Основное отличие "реальной" функции `ask` от примера выше будет в том, что она использует более сложные способы взаимодействия с пользователем, чем простой вызов `confirm`. В браузерах такие функции обычно отображают красивые диалоговые окна.

**Аргументы функции `ask` ещё называют *функциями-колбэками* или просто *колбэками*.**

Ключевая идея в том, что мы передаём функцию и ожидаем, что она вызовется обратно (от англ. "call back" - обратный вызов) когда-нибудь позже, если это будет необходимо. В нашем случае, `showOk` становится *колбэком*' для ответа "yes", а `showCancel` -- для ответа "no".

Мы можем переписать этот пример значительно короче, используя Function Expression:

```js run no-beautify
function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}


ask(
  "Вы согласны?",
  function() { alert("Вы согласились."); },
  function() { alert("Вы отменили выполнение."); }
);

```
Здесь функции объявляются прямо внутри вызова `ask(...)`. У них нет имён, поэтому они называются *анонимными*. Такие функции недоступны снаружи `ask` (потому что они не присвоены переменным), но это как раз то, что нам нужно.

## Function Expression в сравнении с Function Declaration

Во-первых, синтаксис: как определить, что есть что в коде.

- Function Declaration: функция объявляется отдельной конструкцией "function..." в основном потоке кода.

    ```js
    // Function Declaration
    function sum(a, b) {
      return a + b;
    }
    ```
- Function Expression: функция, созданная внутри другого выражения или синтаксической конструкции. В данном случае функция создаётся в правой части "выражения присваивания" `=`:

    ```js
    // Function Expression
    let sum = function(a, b) {
      return a + b;
    };
    ```
Более тонкое отличие состоит, в том, *когда* создаётся функция движком JavaScript.

**Function Expression создаётся, когда выполнение доходит до него, и затем уже может использоваться.**

После того, как поток выполнения достигнет правой части выражения присваивания `let sum = function…` -- с этого момента, функция считается созданной и может быть использована (присвоена переменной, вызвана и т.д. ).

С Function Declaration всё иначе.

**Function Declaration можно использовать во всем скрипте (или блоке кода, если функция объявлена в блоке).**

Другими словами, когда движок JavaScript *готовится* выполнять скрипт или блок кода, прежде всего он ищет в нём Function Declaration и создаёт все такие функции.  Можно считать этот процесс "стадией инициализации".

И только после того, как все объявления Function Declaration будут обработаны, продолжится выполнение.

В результате, функции, созданные, как Function Declaration могут быть вызваны раньше своих определений.

Например, так будет работать:

```js run refresh untrusted
*!*
sayHi("Вася"); // Привет, Вася
*/!*

function sayHi(name) {
  alert( `Привет, ${name}` );
}
```

Функция `sayHi` была создана, когда движок JavaScript подготавливал скрипт к выполнению, и такая функция видна повсюду в этом скрипте.

...Если бы это было Function Expression, то такой код вызовет ошибку:

```js run refresh untrusted
*!*
sayHi("Вася"); // ошибка!
*/!*

let sayHi = function(name) {  // (*) магии больше нет
  alert( `Привет, ${name}` );
};
```

Функции, объявленные при помощи Function Expression, создаются тогда, когда выполнение доходит до них. Это случится только на строке, помеченной звёздочкой `(*)`. Слишком поздно.

Ещё одна важная особенность Function Declaration заключается в их блочной области видимости.

**В строгом режиме, когда Function Declaration находится в блоке `{...}`, функция доступна везде внутри блока. Но не снаружи него.**

Для примера давайте представим, что нам нужно создать функцию `welcome()` в зависимости от значения переменной `age`, которое мы получим во время выполнения кода. И затем запланируем использовать её когда-нибудь в будущем.

Такой код, использующий Function Declaration, работать не будет:

```js run
let age = prompt("Сколько Вам лет?", 18);

// в зависимости от условия объявляем функцию
if (age < 18) {

  function welcome() {
    alert("Привет!");
  }

} else {

  function welcome() {
    alert("Здравствуйте!");
  }

}

// ...не работает
*!*
welcome(); // Error: welcome is not defined
*/!*
```
Это произошло, так как объявление Function Declaration видимо только внутри блока кода, в котором располагается.

Что можно сделать, чтобы `welcome` была видима снаружи `if`?

Верным подходом будет воспользоваться функцией, объявленной при помощи Function Expression, и присвоить значение `welcome` переменной, объявленной снаружи `if`, что обеспечит нам нужную видимость.

Такой код работает, как ожидалось:

```js run
let age = prompt("Сколько Вам лет?", 18);

let welcome;

if (age < 18) {

  welcome = function() {
    alert("Привет!");
  };

} else {

  welcome = function() {
    alert("Здравствуйте!");
  };

}

*!*
welcome(); // теперь всё в порядке
*/!*
```

Можно упростить этот код ещё сильнее, используя условный оператор `?`:

```js run
let age = prompt("Сколько Вам лет?", 18);

let welcome = (age < 18) ?
  function() { alert("Привет!"); } :
  function() { alert("Здравствуйте!"); };

*!*
welcome(); // теперь всё в порядке
*/!*
```
###Когда использовать Function Declaration, а когда Function Expression?
Как правило, если нам понадобилась функция, в первую очередь нужно рассматривать синтаксис Function Declaration, который мы использовали до этого. Он даёт нам больше свободы в том, как мы можем организовывать код. Функции, объявленные таким образом, можно вызывать до их объявления.

Также функции вида `function f(…) {…}` чуть более заметны в коде, чем `let f = function(…) {…}`. Function Declaration легче "ловятся глазами".

...Но если Function Declaration нам не подходит по какой-то причине (мы рассмотрели это в примере выше), то можно использованать объявление при помощи Function Expression.

## Функции-стрелки [#arrow-functions]

Существует ещё более простой и краткий синтаксис для создания функций, который часто лучше, чем синтаксис Function Expression. Он называется "функции-стрелки" или "стрелочные функции" (arrow functions), т.к. выглядит следующим образом:

```js
let func = (arg1, arg2, ...argN) => expression
```
...Такой код создаёт функцию `func` с аргументами `arg1..argN` и вычисляет `expression` с правой стороны с их использованием, возвращая результат.

Другими словами, это почти то же самое, что и:

```js
let func = function(arg1, arg2, ...argN) {
  return expression;
};
```

```js run
let sum = (a, b) => a + b;

/* Функция-стрелка более краткая форма для:

let sum = function(a, b) {
  return a + b;
};
*/

alert( sum(1, 2) ); // 3

```

Если у нас только один аргумент, то круглые скобки вокруг параметров можно опустить, сделав запись ещё короче:

```js run
// тоже что и
// let double = function(n) { return n * 2 }
*!*
let double = n => n * 2;
*/!*

alert( double(3) ); // 6
```

Если нет аргументов, используются пустые круглые скобки (их указывать обязательно):

```js run
let sayHi = () => alert("Hello!");

sayHi();
```

Функции-стрелки могут быть использованы так же, как и Function Expression.

Например, вот переписанный пример уже знакомой нам функции `welcome()`:

```js run
let age = prompt("Сколько Вам лет?", 18);

let welcome = (age < 18) ?
  () => alert('Привет') :
  () => alert("Здравствуйте!");

welcome(); // теперь всё в порядке
```

## Итого

- Функции - это значения. Они могут быть присвоены, скопированы или объявлены в другом месте кода.
- Если функция объявлена как отдельная инструкция в основном потоке кода, то это Function Declaration.
- Если функция была создана как часть выражения, то считается, что эта функция объявлена при помощи Function Expression.
- Function Declaration обрабатываются перед выполнением блока кода. Они видны во всём блоке.
- Функции, объявленные при помощи Function Expression, создаются, только когда поток выполнения достигает их.

В большинстве случаев, когда нам нужно создать функцию, предпочтительно использовать Function Declaration, т.к. функция будет видима до своего объявления в коде. Это позволяет более гибко организовывать код, и улучшает его читаемость.

Таким образом, мы должны прибегать к объявлению функций при помощи Function Expression в случае, когда синтаксис Function Declaration не подходит для нашей задачи. Мы рассмотрели несколько таких примеров в этой главе, и рассмотрим их ещё больше в будущем.

Функции-стрелки очень удобны для однострочных действий. Они бывают двух типов:

1. Без фигурных скобок: `(...args) => expression` -- правая сторона выражение: функция выполняет его и возвращает результат.
2. С фигурными скобками: `(...args) => { body }` -- скобки позволяют нам писать многосточные инструкции внутри функции, но при этом необходимо указывать директиву `return`, чтобы вернуть какое-либо значение.



