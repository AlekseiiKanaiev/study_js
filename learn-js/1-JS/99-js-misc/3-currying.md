# Каррирование

[Каррирование](https://ru.wikipedia.org/wiki/%D0%9A%D0%B0%D1%80%D1%80%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5) - продвинутая техника для работы с функциями. Она используется не только в JavaScript, но и в других языках.

Каррирование - это трансформация функций таким образом, чтобы они принимали  аргументы не как `f(a, b, c)`, а как `f(a)(b)(c)`.

Каррирование не вызывает функцию. Оно просто трансформирует её.

Создадим вспомогательную функцию `curry(f)`, которая выполняет каррирование функции `f` с двумя аргументами. Другими словами, `curry(f)` для функции `f(a, b)` трансформирует её в `f(a)(b)`.

```js run
function curry(f){
    // curry(f) выполняет каррирование
    return function(a){
        return function(b){
            return f(a, b);
        };
    };
}

// использование
function sum(a, b){
    return a + b;
}

let carriedSum = curry(sum);

alert(carriedSum(1)(2)); // 3
```

Как вы видите, реализация довольна проста: это две обёртки.

- Результат `curry(func)` -- обёртка `function(a)`.
- Когда она вызывается как `sum(1)`, аргумент сохраняется в лексическом окружении и возвращается новая обёртка `function(b)`.
- Далее уже эта обёртка вызывается с аргументом `2` и передаёт вызов к оригинальной функции `sum`.

Более продвинутые реализации каррирования, как например [_.curry](https://lodash.com/docs#curry) из библиотеки lodash, возвращают обёртку, которая позволяет запустить функцию как обычным образом, так и частично.

```js run
function sum(a, b) {
  return a + b;
}

let carriedSum = _.curry(sum); // используем _.carry из lodash

alert( carriedSum(1, 2) ); // 3, можно вызывать как обычно
alert( carriedSum(1)(2) ); // 3, а можно частично
```

## Каррирование? Зачем?

Чтобы понять пользу от каррирования, нам определённо нужен пример из реальной жизни.

Например, у нас есть функция логирования `log(date, importance, message)`, которая форматирует и выводит информацию. В реальных проектах у таких функций есть много полезных возможностей, например, посылать логи по сети, здесь для простоты используем `alert`:

```js
function log(date, importance, message) {
  alert(`[${date.getHours()}:${date.getMinutes()}] [${importance}] ${message}`);
}
```

А теперь давайте применим к ней каррирование!

```js
log = _.curry(log);
```

После этого `log` продолжает работать нормально:

```js
log(new Date(), "DEBUG", "some debug"); // log(a, b, c)
```

...Но также работает вариант с каррированием:

```js
log(new Date())("DEBUG")("some debug"); // log(a)(b)(c)
```

Давайте сделаем удобную функцию для логов с текущим временем:

```js
// logNow будет частичным применением функции log с фиксированным первым аргументом
let logNow = log(new Date());

// используем её
logNow("INFO", "message"); // [HH:mm] INFO message
```

Теперь `logNow` - это `log` с фиксированным первым аргументом, иначе говоря, "частично применённая" или "частичная" функция.

Мы можем пойти дальше и сделать удобную функцию для именно отладочных логов с текущим временем:

```js
let debugNow = logNow("DEBUG");

debugNow("message"); // [HH:mm] DEBUG message
```

Итак:
1. Мы ничего не потеряли после каррирования: `log` всё так же можно вызывать нормально.
2. Мы можем легко создавать частично применённые функции, как сделали для логов с текущим временем.

## Продвинутая реализация каррирования

Вот "продвинутая" реализация каррирования для функций с множеством аргументов, которую мы могли бы использовать выше.

Она очень короткая:

```js
function curry(f) {
    return function curried(...args){
        if (args.length >= f.length) { // (1)
            return f.apply(this, args);
        } esle {
            return function(...args2) { // (2)
                return curried.apply(this, args.concat(args2));
            };
        }
    };
}
```

Примеры использования:

```js
function sum(a, b, c) {
  return a + b + c;
}

let curriedSum = curry(sum);

alert( curriedSum(1, 2, 3) ); // 6, всё ещё можно вызывать нормально
alert( curriedSum(1)(2,3) ); // 6, каррирование первого аргумента
alert( curriedSum(1)(2)(3) ); // 6, каррирование всех аргументов
```

Результат вызова `curry(func)` -- это обёртка `curried`.

Когда мы запускаем её, есть две ветви выполнения `if`:

1. Вызвать сейчас: если количество переданных аргументов `args` совпадает с количеством аргументов при объявлении функции (`func.length`) или больше, тогда вызов просто переходит к ней.
2. Частичное применение: в противном случае `func` не вызывается сразу. Вместо этого, возвращается другая обёртка, которая снова применит `curried`, передав предыдущие аргументы вместе с новыми. Затем при новом вызове мы опять получим либо новое частичное применение (если аргументов недостаточно) либо, наконец, результат.

### "Только функции с фиксированным количеством аргументов"

Функцию, которая использует остаточные параметры, типа `f(...args)`, так каррировать не получится.

### "Немного больше, чем каррирование"

Но, как было описано, большинство реализаций каррирования в JavaScript более продвинуты: они также оставляют вариант вызова функции с несколькими аргументами.

## Итого

*Каррирование* -- это трансформация, которая превращает вызов `f(a, b, c)` в `f(a)(b)(c)`. В JavaScript реализация обычно позволяет вызывать функцию обоими вариантами: либо нормально, либо возвращает частично применённую функцию, если количество аргументов недостаточно.

Каррирование позволяет легко получать частичные функции. Как мы видели в примерах с логами: универсальная функция `log(date, importance, message)` после каррирования возвращает нам частично применённую функцию, когда вызывается с одним аргументом, как `log(date)` или двумя аргументами, как `log(date, importance)`.


