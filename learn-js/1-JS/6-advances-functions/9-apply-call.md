# Декораторы и переадресация вызова, сall/apply

JavaScript предоставляет исключительно гибкие возможности по работе с функциями: они могут быть переданы в другие функции, использованны как объекты, и сейчас мы рассмотрим как *перенаправить* вызовы между ними и как их декорировать.

## Прозрачное кеширование

Представим, что у нас есть функция `slow(x)`, выполняющая ресурсоемкие вычисления, но возвращающая стабильные результаты. Т.е. для одного и того же `x` она всегда возвращает один и тот же результат.

Если функция вызывается часто, то ее можно кешировать (запомнить) возвращаемые еюрезультаты, чтобы сэкономить время на повторных вычислениях.

Вместо того, чтобы усложнять `slow(x)` дополнительной функциональностью мы заключим ее в функцию-обертку - "wrapper" (от англ. "wrap" - обёртывать), которая добавит кеширование.

```js run
function slow(x){
    // здесь могут быть CPU ресурсоёмкие вычисления
    alert(`Called with ${x}`);
    return x;
}

function cachingDecorator(func){
    let cache = new Map();

    return function(x){
        if(cache.has(x)){
            // если кэш содержит такой x
            return cache.get(x);// читаем из него результат
        }

        let result = func(x);// иначе, вызываем функцию и записывает результат в переменную

        cache.set(x, result)// и кешируем (запоминаем) результат
        return result;
    }
}

slow = cachingDecorator(slow);
alert(slow(1)); // slow(1) кешируем
alert('Again: ' + slow(1)); // возвращаем кеш
alert( slow(2) ); // slow(2) кешируем
alert( "Again: " + slow(2) ); // возвращаем кеш
```

В коде выше `cachingDecorator` -- это *декотатор*, специальная функция, которая принимает другую функцию и изменяет ее поведение.

Идея состоит в том, чтобы вызвать `cachingDecorator` с любой функцией, в результате чего мы получим кеширующую обертку. У нас может быть множество функций, исполльзующих такой функционал.

Отделяя кеширующий код от основного кода, мы также сохраняем чистоту и простоту последнего.

Результат вызова `cachingDecorator(func)` является "обёрткой", т.е. `function(x)` "оборачивает"вызов `func(x)` в кеширующую логику.

С точки зрения внешнего кода, обернутая функция `slow` по-прежнему делает то же самое. Обертка всего добавляет к ее поведению аспект кеширования.

Подводя итог, можно выделить несколько преимуществ использования отдельной `cachingDecorator` вместо испольщования самой  `slow`:

- Функцию `cachingDecorator` можно использовать повторно. Мы можем применить ее к другой функции.
- Логика кеширования явлется отдельной, она не увеличивает сложность самой `slow`.
- При необходимости мы можем объединить несколько декораторов.


## Применение "func.call" для передачи контекста.

Упомянутый выше кеширующий декоратор не подходит для работы с методами объектов.

Например,  в приведенном ниже коде `worker.slow()` перестает работать после применения декоратора:

```js run
// сделаем worker.slow кеширующим
let worker = {
    someMethod() {
        return 1;
    },
    slow(x) {
        // здесь может быть страшно тяжёлая задача для процессора 
        alert('Called with ' + x);
        return x * this.someMethod(); // (*)
    }
};

// тот же код, что и выше
function cachingDecorator(func) {
    let cache = new Map();
    return function(x) {
        if (cache.has(x)) {
            return cache.get(x);
        }
        let result = func(x); //(**)

        cache.set(x, result);
        return result;
    }
}

alert (worker.slow(1)); // оригинальный метод работает

worker.slow = cachingDecorator(worker.slow); // теперь сделаем его кеширующим

alert(worker.slow(2));
```

Ошибка возникнет в строке `(*)`. Функция пытается получить доступ к `this.someMethod` и завершается с ошибкой. Причина в том, что в строке `(**)` декоратор вызывает оригинальную функцию как `func(x)`, а в этом случае функция получает `this = undefined`.

Похожий результат получился бы, если бы мы попытались запустить:

```js
let func = worker.slow;
func(2);
```

Т.е. декоратор передает вызов оригинальному методу, но без контекста. Следовательно -- ошибка.

Давайте это исправим.

Существует специальный встроегнный метод функции [func.call(context, ...args)](mdn:js/Function/call), который позволяет вызывать функцию, явно устанавливая `this`.

Синтаксис:

```js
func.call(context, arg1, arg2, ...)
```

Он запускает функцию `func`, предоставляя первый аргумент как `this`, а последующие как ее аргументы.

Проще говоря, эти два вызова делают почти то же свмое:

```js
func(1, 2, 3);
func.call(obj, 1, 2, 3)
```

Они оба вызываю `func` с аргументами `1`, `2` и `3`. Единственное отличие в том, что `func.call` также устанавливает `this` в `obj`.

Например, в приведенном ниже коде мы вызываем `sayHi` в контексте различных объектов: `sayHi.call(user)` запускает `sayHi`, передавая `this=user`, а следующая строка устанавливает `this=admin`:

```js run
function sayHi() {
    alert(this.name);
}

let user = { name: 'John' };
let admin = { name: 'Admin' };

// используем 'call' для передачи различных объектов как 'this'
sayHi.call(user); // this = John
sayHi.call(admin); // this = Admin
```

Здесь мы используем `call` для вызова `say` с заданным контекстом и фразой:

```js run
function say(phrase) {
    alert (this.name + ', ' + phrase)
}
let user = { name: 'John' };

// 'user' становится 'this', и "Hello" становится первым аргументом
say.call(user, 'Hello'); // John, Hello
```

В нашем случае мы можем использовать `call` в обертке для передачи контекста в исходную функцию:

```js run
function worker = {
    someMethod() {
        return 1;
    }

    slow(x) {
        alert('called with ' + x);
        return x * this.someMethod(); // (*)
    }
};

function cachingDecorator(func){
    let cache = new Map();
    return function(x) {
        if (cache.has(x)) {
            return cache.get(x);
        }
        let result = func.call(this, x); // теперь 'this' передаётся правильно

        cache.set(x, result);
        return result;
    }
}

worker.slow = cachingDecorator(worker.slow); // теперь сделаем её кеширующей

alert(worker.slow(2)) //works
alert(worker.slow(2)) // // работает, не вызывая первоначальную функцию (кешируется)
```

Чтобы все было понятно, давайте посмотрим глубже, как передается `this`:

1. После *декорации* `worker.slow` становится оберткой `function (x) { ... }`.
2. Так что при выполнении `worker.slow(2)` оберка получит `2` в качестве аргумента, и `this=worker` (так как это объект перед точкой).
3. Внутри обертки, если результат еще не кеширован, func.call(this, x)` передает текущий `this` (`=worker`) и текущий аргумент (`=2`) в оригинальную функцию.

## Переходим к нескольким аргументам с "func.apply"

Сделаем `cachingDecorator` ещ более универсальным, т.к. сейчас он работает только с функциями с одним аргументом.

Переделаем функция для кеширования методов с несколькими аргусентами:

```js
let worker = {
    slow(min, max) {
        return min + max; // здесь может быть тяжёлая задача
    }
};

// should remember same-argument calls
worker.slow = cachingDecorator(worker.slow);
```

Получаем две задачи, которые необходимо решить:

Во-первых, - как использовать оба аргумента `min` и `max` для ключа в коллеции `cache`. Ранее для одного аргумента `x` мы могли просто сохранить результат `cache.set(x, result)` и вызвать `cache.get(x)` чтобы получить его. Теперь же нам нужно запомнить резульат для *комбинации пргументов* `(min,max)`. Встроенный `Map` принимает только одно значение как ключ.

Есть много возможных решений:

1. Реализовать новую (или использовать стороннюю) структуру данных для коллеекции, которая более универсальная чем всстроенный `Map`, и поддерживает множественные ключи.
2. Использовать вложенные коллекции: `cache.set(min)` будет `Map` которая хранит пару `(max, result)`. Тогда получить `result` мы можем вызвать `cache.get(min).get(max)`.
3. Соеденить два значения в одно. В нашем конкретном случае мы можем просто использовать строку `"min,max"` как ключ к `Map`. Для гибкости, мы можем позволить передавать *хеширующую функцию* в декоратор, которая знает, как сделать одно значение из многих.

Для многих практических применений третий вариант достаточно хорошо, поэтому мы будем исполльзовать его:

Заменим `func.call(this, x)` на `func.call(this, ...arguments)`, чтобы передавать все аргументы обернутой функции, а не только первый.

Вот более мощный `cachingDecorator`:

```js run
let worker = {
    slow(min, max) {
        alert(`Called with ${min},${max}`);
        return min + max;
    }
};

fuction cachingDecorator( func, hash ){
    let cache = new Map();
    return function() {
        let key = hash(arguments); // (*)
        if (cache.has(key)) {
            return cache.get(key);
        }
        let result = func.call(this, ...arguments); // (**)
        cache.set(key, result);
        return result;
    };
}

function hash(args) {
    return args[0] + ',' args[1];
}

worler.slow = cachingDecorator(worker.slow, hash);

alert(worker.slow(3, 5)); // works!
alert('Again ' + worker.slow(3, 5)); // works too!
```

Теперь он работает с любым количеством аргументов.

Мы внесли два изменения:

- В строке `(*)` вызываем `hash` для создания одного ключа из `arguments`, используя простую функцию "объелинения", которая превращает аргументы  `(3, 5)` в ключ `" 3,5 "`. В более сложных функциях могут использоваться другие функции хешированния.
- Затем в строке `(**)` используем `func.call(this, ...arguments)`  для передачи как контекста, так и всех аргументов, полученных оберткой (независимо от их количества), в исходную функцию.

Вместо `func.call(this, ...arguments)` мы могли бы использовать `func.apply(this, arguments)`.

Синтаксис встроенного метода  [func.apply](mdn:js/Function/apply):

```js
func.apply(context, args)
```

Он выполняет `func`, устанавливая `this=context` и принима в качестве аргументов псевдомассив `args`. 

Единственная разница в синтаксисе между `call` и `apply` состоит в том, что `call` ожидает список аргументов, в то время как `apply` принимает псевдомассив. 

Эти два варианта почти эквивалентны:


```js
func.call(context, ...args); // передаёт массив как список с оператором расширения
func.apply(context, args);   // тот же эффект
```

Есть толлько одна небольшая разница:

- Оператор расширения `...` позволяет передавать *перебираемый* объект `args` в виде списка в `call`.
- А `apply` принимает только *псевдомассив* `args`.

Так что эти вызовы дополняют друг друга. Для перебираемых объетов сработает `call`, а где мы ожидаем псевдомассив - `apply`.

А если у нас объект, который и то и другое, например, реальный массив, то технически мы могли бы использовать любой, но `apply`, вероятно, будет быстрее, потому что большинство движков JavaScript внутренне оптимизируют его лучше.

Передвча всех аргументов вместе с контекстом другой фукции называется "перенаправлением вызова" `(call forwarding)`.

Простейший вид такого перенаправления:

```js
let wrapper = function() {
  return func.apply(this, arguments);
};
```

При вызове `wrapper` из внешнего кода его не отличить от вызова исходной фукции.

## Заимствование метода [#method-borrowing]

Теперь давайте сделаем ещё одно небольшое улучшение функции хеширования:

```js
function hash(args) {
  return args[0] + ',' + args[1];
}
```

На данный момент она работает только для двух аргументов. Было бы лучше, если бы она могла "склеить" любое количество `args`.

Естественным решением было бы использовать метод [arr.join](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/join):

```js
function hash(args) {
  return args.join();
}
```

Однако это не сработает. Потому что мы вызываем `hash(arguments)`, а объект `arguments` является перебираемым и севдомассивом, но не реальным массивом.

Таким образом, вызов `join` для него не сработает:

```js run
function hash() {
*!*
  alert( arguments.join() ); // Ошибка: arguments.join не является функцией
*/!*
}

hash(1, 2);
```

Но есть простой способ исполльзовать соединение массива:

```js run
function hash() {
*!*
  alert( [].join.call(arguments) ); // 1,2
*/!*
}

hash(1, 2);
```

Это называется *заимствование метода*.

Мы берем (заимствуем) метод `join` из обычного массива `[].join`. И исполльзуем `[].join.call`, чтобы выполнить его в контексте `arguments`.

Это работает из-за того, что внутренний алгоритм встроенного метода `arr.join(glue)` очень прост. Из спецификации:

1. Пускай первым аргументом будет `glue` или, в случае отсутствия аргументов, им будет запятая `","`.
2. Пускай `result` будет пустой строкой `""`.
3. Добавить `this[0]` к `result`.
4. Добавить `glue` и `this[1]`.
5. Добавить `glue` и `this[2]`.
6. ...выполнять до тех пор, пока `this.length` элементов не будет склеено.
7. Вернуть `result`.

Таким образом, техничкески он принимает `this` и объединяет `this[0]`, `this[1]`... и т.д. вместе. Он намеренно написан так, что допускает любой псевдомассив `this` (не случайно, многие методы следуют этой практике). Вот почему он также работает с `this=arguments`.

## Итого

*Декоратор* - это обертка вокруг функции, которая изменяет поведение последней. Основная работа по-прежнему выполняется функцией. 

Обычно безопасно заменить функцию или метод декорированным, за исключением одной мелочи. Если исходная функция предоставляет свойства, такие как `func.calledCount` или типа того, то декорированная функция их не предоставит. Потому что это обертка. Следовательно нужно быть осторожным в их использовании. Некоторые декораторы предоставляют собственные свойства. 

Декораторы можно рассматривать "дополнительные возможности" или "аспекты", которые можно добавить в функцию. Мы можем добавить один или несколько. И все это без изменения ее кода!

Для реализации `cachingDecorator` мы изучили методы:

- [func.call(context, arg1, arg2...)](mdn:js/Function/call) -- вызывает `func` с данным контекстом и аргументами.
- [func.apply(context, args)](mdn:js/Function/apply) -- вызывает `func` передавая `context` как `this` и псевдомассив `args` как список аргументов.

В основном *переадресация вызова* выполняется с помощью `apply`:

```js
let wrapper = function(original, arguments) {
  return original.apply(this, arguments);
};
```

Мы также рассмотрели пример *заимствования метода*, когда мы вызываем метод у объекта в контексте другого объекта. Весьма распространено заимствовать методы массива и применять их к `arguments`. В качестве альтернативы можно использовать объект с остаточными параметрами `...args`, который является реальным массивом.

На практике декораторы используются для самых разных задач.

